import { getServerSession } from 'next-auth/next';
import { authOptions } from '../auth/[...nextauth]';
import connectToDatabase from '@/lib/mongodb';
import Chat from '@/models/Chat';
import User from '@/models/User';
import mongoose from 'mongoose';

/**
 * Auto-Generate Flashcards from Chat History
 * Scans conversations and creates flashcards from Q&A pairs
 * POST /api/flashcards/from-chats
 */
export default async function handler(req, res) {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        await connectToDatabase();

        const session = await getServerSession(req, res, authOptions);
        if (!session?.user?.email) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        const user = await User.findOne({ email: session.user.email });
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        const { limit = 10, minDays = 7 } = req.body;

        // Get chats from last N days
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - minDays);

        const recentChats = await Chat.find({
            userEmail: session.user.email,
            createdAt: { $gte: cutoffDate }
        })
            .sort({ createdAt: -1 })
            .limit(50)
            .lean();

        if (recentChats.length === 0) {
            return res.status(200).json({
                success: true,
                flashcardsCreated: 0,
                message: 'No recent conversations found'
            });
        }

        // Extract Q&A pairs suitable for flashcards
        const flashcards = [];

        recentChats.forEach(chat => {
            const messages = chat.messages || [];

            for (let i = 0; i < messages.length - 1; i++) {
                const userMsg = messages[i];
                const aiMsg = messages[i + 1];

                // Check if it's a user question followed by AI answer
                if (userMsg.sender === 'user' && aiMsg.sender === 'assistant') {
                    const question = userMsg.text?.trim();
                    const answer = aiMsg.text?.trim();

                    // Quality checks
                    if (isGoodFlashcardQuestion(question) && isGoodFlashcardAnswer(answer)) {
                        const topic = extractTopicFromText(question);
                        const difficulty = determineDifficulty(question);

                        flashcards.push({
                            front: question,
                            back: answer,
                            topic,
                            difficulty,
                            source: 'chat',
                            sourceDate: chat.createdAt,
                            tags: extractKeywords(question + ' ' + answer)
                        });
                    }
                }
            }
        });

        // Limit number of flashcards
        const selectedFlashcards = flashcards.slice(0, limit);

        // Save to user's flashcard collection (if you have a Flashcard model)
        // For now, we'll add to user profile
        if (!user.profile) user.profile = {};
        if (!user.profile.autoGeneratedFlashcards) user.profile.autoGeneratedFlashcards = [];

        const newCards = selectedFlashcards.map(card => ({
            ...card,
            _id: new mongoose.Types.ObjectId(),
            createdAt: new Date(),
            reviewed: false,
            reviewCount: 0
        }));

        user.profile.autoGeneratedFlashcards.push(...newCards);

        // Keep only last 50 auto-generated flashcards
        if (user.profile.autoGeneratedFlashcards.length > 50) {
            user.profile.autoGeneratedFlashcards = user.profile.autoGeneratedFlashcards.slice(-50);
        }

        await user.save();

        return res.status(200).json({
            success: true,
            flashcardsCreated: newCards.length,
            flashcards: newCards,
            message: `Created ${newCards.length} flashcards from your recent conversations!`
        });

    } catch (error) {
        console.error('Error generating flashcards from chats:', error);
        return res.status(500).json({
            error: 'Internal server error',
            message: error.message
        });
    }
}

// Helper functions
function isGoodFlashcardQuestion(question) {
    if (!question || question.length < 10 || question.length > 300) return false;

    // Should be a clear question
    const hasQuestionWord = /^(what|who|when|where|why|how|explain|define|describe|compare|discuss)/i.test(question);
    const endsWithQuestion = question.trim().endsWith('?');

    // Avoid conversational chatter
    const isCasualChat = /(thanks|thank you|okay|got it|i see|interesting|cool)/i.test(question);

    return (hasQuestionWord || endsWithQuestion) && !isCasualChat;
}

function isGoodFlashcardAnswer(answer) {
    if (!answer || answer.length < 50) return false; // Too short
    if (answer.length > 2000) return false; // Too long for flashcard

    // Avoid answers that are just questions back
    if (answer.split('?').length > 3) return false;

    return true;
}

function extractTopicFromText(text) {
    if (!text) return 'General';
    const lowerText = text.toLowerCase();

    if (lowerText.includes('polity') || lowerText.includes('constitution') || lowerText.includes('government')) return 'Polity';
    if (lowerText.includes('history') || lowerText.includes('ancient') || lowerText.includes('medieval')) return 'History';
    if (lowerText.includes('geography') || lowerText.includes('climate') || lowerText.includes('map')) return 'Geography';
    if (lowerText.includes('economy') || lowerText.includes('economic') || lowerText.includes('finance')) return 'Economics';
    if (lowerText.includes('science') || lowerText.includes('technology')) return 'Science & Technology';
    if (lowerText.includes('environment') || lowerText.includes('ecology')) return 'Environment';
    if (lowerText.includes('ethics') || lowerText.includes('integrity')) return 'Ethics';
    if (lowerText.includes('current affairs') || lowerText.includes('news')) return 'Current Affairs';

    return 'General';
}

function determineDifficulty(question) {
    const text = question.toLowerCase();

    if (/^(what is|who is|when|where|define)/i.test(text)) return 'Easy';
    if (/critically|analyze|evaluate|assess|implications/i.test(text)) return 'Hard';
    return 'Medium';
}

function extractKeywords(text) {
    // Simple keyword extraction - could be improved with NLP
    const words = text.toLowerCase()
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(w => w.length > 4); // Words longer than 4 chars

    const stopWords = ['about', 'which', 'their', 'there', 'these', 'those', 'would', 'could', 'should'];
    const filtered = words.filter(w => !stopWords.includes(w));

    // Get unique keywords
    const unique = [...new Set(filtered)];

    return unique.slice(0, 5); // Top 5 keywords
}
