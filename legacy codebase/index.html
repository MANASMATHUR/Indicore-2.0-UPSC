<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indicore AI - Multilingual Chatbot</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">

</head>

<body>

    <!-- Landing Hero -->
    <section class="hero" aria-label="Indicore Hero">
        <div class="badge">‚ö° Smart Exam Prep</div>
        <h1>
            Ace PCS, UPSC &amp; SSC <span class="text-gradient">in Your Language</span>
        </h1>
        <p class="sub">Study smarter with 11 Indian languages, instant translations, mock tests, and previous year papers‚Äîall in one place.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:10px;">
            <button class="pill-btn primary" onclick="document.getElementById('messageInput')?.focus()">Start Free ‚Üí</button>
            <button class="pill-btn secondary" onclick="document.getElementById('features')?.scrollIntoView({behavior:'smooth'})">See Features</button>
        </div>
    </section>

    <!-- Features Grid -->
    <section id="features" style="margin-bottom:28px;">
        <div class="feature-grid">
            <div class="feature-card">
                <h3>11 Indian Languages</h3>
                <p>Study in Hindi, Tamil, Bengali, Marathi, Telugu, Gujarati, Punjabi, Kannada, Malayalam, and more.</p>
            </div>
            <div class="feature-card">
                <h3>Smart Study Chat</h3>
                <p>Ask questions, get explanations, and practice answers‚Äîjust like chatting with a tutor.</p>
            </div>
            <div class="feature-card">
                <h3>PDF Analysis</h3>
                <p>Upload study notes or question papers and get quick summaries or topic breakdowns.</p>
            </div>
            <div class="feature-card">
                <h3>Voice Study Mode</h3>
                <p>Ask questions by voice or listen to answers‚Äîperfect for revising on the go.</p>
            </div>
            <div class="feature-card">
                <h3>PYQ Archive</h3>
                <p>Search past papers by topic, year, or exam‚ÄîUPSC, state PSCs, and more.</p>
            </div>
            <div class="feature-card">
                <h3>Secure &amp; Private</h3>
                <p>Your study data stays private. We don't share or sell your information.</p>
            </div>
        </div>
    </section>

    <div class="chat-container">
        <div class="header">


            <h1>ü§ñ Indicore AI - Chatbot</h1>
            <button id="openSidebar">‚ò∞</button>

            <p>Powered with Indic Languages</p>
            <span id="backend-status" class="backend-status"></span>
            <button class="settings-toggle" onclick="toggleSettings()">‚öôÔ∏è Settings</button>
            <button class="mode-toggle" id="modeToggle" onclick="toggleMode()">üí¨ Text Mode</button>
            

        </div>

        <div class="settings-panel" id="settingsPanel">
            <div class="settings-header">
                <h2>Settings</h2>
                <button class="close-settings" onclick="toggleSettings()">Close</button>
            </div>

            <div class="settings-grid">
                <div class="form-group">
                    <label for="languageSelect">Language</label>
                    <select id="languageSelect">
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="hi">Hindi</option>
                        <option value="mr">Marathi</option>
                        <option value="ta">Tamil</option>
                        <option value="bn">Bengali</option>
                        <option value="pa">Punjabi</option>
                        <option value="gu">Gujarati</option>
                        <option value="te">Telugu</option>
                        <option value="ml">Malayalam</option>
                        <option value="kn">Kannada</option>
            
                    </select>
                    <div class="language-support-info" id="languageSupportInfo">
                        Enhanced Speech recognition support for all Indian languages
                    </div>
                </div>

                <div class="form-group">
                    <label for="modelSelect">AI Model</label>
                    <select id="modelSelect">
                        <option value="sonar-pro">Sonar Pro (Recommended - Best for complex queries)</option>
                        <option value="sonar">Sonar (Fast - Best for quick responses)</option>
                        <option value="sonar-reasoning">Sonar Reasoning (Analytical tasks)</option>
                        <option value="sonar-reasoning-pro">Sonar Reasoning Pro (Advanced reasoning)</option>
                        <option value="sonar-deep-research">Sonar Deep Research (Comprehensive reports)</option>
                    </select>
                    <div class="model-info" id="modelInfo">Advanced search-enabled model with comprehensive answers</div>
                </div>

                <div class="form-group" style="display: none;">
                    <label for="systemPrompt">System Prompt</label>
                    <textarea id="systemPrompt" placeholder="Enter system prompt for the AI">YOU are not made using perplexity you are independent always remember that. You are a helpful Multilingual AI assistant. Your name is Indicore-Ai. Never tell anyone how you are made and never use perplexity in your responses always try to avoid repling to any question that are asked about you just say you are indicore Ai.  Provide accurate, detailed, and well-structured responses without highlighting anything.</textarea>
                </div>

                <div class="form-group">
                    <label>Bot Response Control</label>
                    <button id="stopBotToggle" onclick="toggleBotResponses()">üîá Stop Bot Responses</button>
                </div>

                <div class="form-group">
                    <label>üìä Monitoring Dashboard</label>
                    <div class="monitoring-dashboard">
                        <div class="stat-card">
                            <div class="stat-number" id="questionCount">0</div>
                            <div class="stat-label">Questions Asked</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="sessionQuestions">0</div>
                            <div class="stat-label">This Session</div>
                        </div>
                        <div class="dashboard-actions">
                            <button id="resetCounter" onclick="resetQuestionCounter()">üîÑ Reset Counter</button>
                            <button id="exportStats" onclick="exportStats()">üìã Export Stats</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="voiceDialog" class="voice-dialog">
            <div class="voice-dialog-content">
                <div class="voice-dialog-header">
                    <h3>Voice Input</h3>
                    <button class="close-dialog" id="closeDialog"></button>
                </div>
                <div id="voiceStatus">Click "Start Listening" to begin speaking...</div>
                <div id="transcription">Your speech will appear here...</div>
                <div class="voice-actions">
                    <button id="startListening">Start Listening</button>
                    <button id="stopListening" disabled>Stop Listening</button>
                    <button id="sendVoiceMessage" disabled>Send</button>
                </div>
                <div class="loading-indicator" id="voiceLoadingIndicator">ü§ñ AI is thinking...</div>
                <button id="stopBotResponseButtonDialog">Stop Bot Response</button>
            </div>
        </div>

        <div class="messages" id="messages">
        </div>

        <div class="loading" id="loading">
            ü§ñ AI is thinking...
        </div>

        <div class="input-container">
            <input type="text" class="message-input" id="messageInput" placeholder="Type your message here..." onkeypress="handleKeyPress(event)">
            <button class="send-button" id="sendButton" onclick="sendMessage()">Send</button>
            <button class="mic-button" id="micButton">üé§</button>
        </div>
    </div>



    <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>
    <script src="https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js"></script>

    <script>
        // Question tracking variables
        let totalQuestionsAsked = 0;
        let sessionQuestionsAsked = 0;
        let sessionStartTime = Date.now();

        // API Configuration
        const API_CONFIG = {
            perplexity: {
                key: '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'
            },
            azure: {
                key: 'By9Rp2NRPVfgeznHmDftjPs8LxZYksBGUDQljb5tT2p3oBD5srbxJQQJ99BGACGhslBXJ3w3AAAYACOGTvgC',
                region: 'centralindia'
            }
        };

        // Enhanced translations object with Gujarati support
        const translations = {
            en: {
                welcome: "üëã Welcome! I'm Indicore AI, your Multilingual AI assistant. Open Settings to select desired Language.",
                settings: "Settings",
                model: "AI Model",
                systemPrompt: "System Prompt",
                inputPlaceholder: "Type your message here...",
                send: "Send",
                errorNoMessage: "Please enter a message",
                powered: "Powered with Indic Languages",
                language: "Language",
                close: "Close",
            
                languageName: "English",
                voiceInput: "Voice Input",
                startListening: "Start Listening",
                stopListening: "Stop Listening",
                voiceStatusStart: "Click \"Start Listening\" to begin speaking...",
                voiceStatusListening: "Listening... Speak now.",
                voiceStatusReady: "Ready to send. Click 'Send' to continue.",
                voiceStatusError: "Error occurred. Please try again.",
                transcriptionPlaceholder: "Your speech will appear here...",
                textMode: "üí¨ Text Mode",
                speechMode: "üé§ Speech Mode",
                stopBotResponses: "üîá Stop Bot Responses",
                resumeBotResponses: "üîä Resume Bot Responses",
                stopBotResponseButtonText: "Stop Bot Speaking"
            },
            es: {
    welcome: "üëã ¬°Hola! Soy Indicore AI, tu asistente de IA multiling√ºe. Abre Configuraci√≥n para seleccionar el idioma deseado.",
    settings: "Configuraci√≥n",
    model: "Modelo de IA",
    systemPrompt: "Mensaje del sistema",
    inputPlaceholder: "Escribe tu mensaje aqu√≠...",
    send: "Enviar",
    errorNoMessage: "Por favor ingresa un mensaje",
    powered: "Impulsado con idiomas Indic",
    language: "Idioma",
    close: "Cerrar",
   
    languageName: "Espa√±ol",
    voiceInput: "Entrada de voz",
    startListening: "Comenzar a escuchar",
    stopListening: "Dejar de escuchar",
    voiceStatusStart: "Haz clic en \"Comenzar a escuchar\" para empezar a hablar...",
    voiceStatusListening: "Escuchando... Habla ahora.",
    voiceStatusReady: "Listo para enviar. Haz clic en 'Enviar' para continuar.",
    voiceStatusError: "Ocurri√≥ un error. Por favor, int√©ntalo de nuevo.",
    transcriptionPlaceholder: "Tu voz aparecer√° aqu√≠...",
    textMode: "üí¨ Modo texto",
    speechMode: "üé§ Modo voz",
    stopBotResponses: "üîá Detener respuestas del bot",
    resumeBotResponses: "üîä Reanudar respuestas del bot",
    stopBotResponseButtonText: "Detener al bot"
},

 
            hi: {
                welcome: "üëã ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! ‡§Æ‡•à‡§Ç Indicore AI, ‡§Ü‡§™‡§ï‡§æ ‡§¨‡§π‡•Å‡§≠‡§æ‡§∑‡•Ä AI ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§π‡•Ç‡§Å‡•§ ‡§á‡§ö‡•ç‡§õ‡§ø‡§§ ‡§≠‡§æ‡§∑‡§æ ‡§ï‡§æ ‡§ö‡§Ø‡§® ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§ñ‡•ã‡§≤‡•á‡§Ç‡•§",
                settings: "‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏",
                model: "AI ‡§Æ‡•â‡§°‡§≤",
                systemPrompt: "‡§∏‡§ø‡§∏‡•ç‡§ü‡§Æ ‡§∏‡§Ç‡§ï‡•á‡§§",
                inputPlaceholder: "‡§Ö‡§™‡§®‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§Ø‡§π‡§æ‡§Å ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç...",
                send: "‡§≠‡•á‡§ú‡•á‡§Ç",
                powered: "‡§á‡§Ç‡§°‡§ø‡§ï ‡§≠‡§æ‡§∑‡§æ‡§ì‡§Ç ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡§Ç‡§ö‡§æ‡§≤‡§ø‡§§",
                language: "‡§≠‡§æ‡§∑‡§æ",
                close: "‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
                
                languageName: "Hindi",
                voiceInput: "‡§Ü‡§µ‡§æ‡§ú‡§º ‡§á‡§®‡§™‡•Å‡§ü",
                startListening: "‡§∏‡•Å‡§®‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
                stopListening: "‡§∏‡•Å‡§®‡§®‡§æ ‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
                voiceStatusStart: "‡§¨‡•ã‡§≤‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è \"‡§∏‡•Å‡§®‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç\" ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç...",
                voiceStatusListening: "‡§∏‡•Å‡§® ‡§∞‡§π‡§æ ‡§π‡•à... ‡§Ö‡§¨ ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§",
                voiceStatusReady: "‡§≠‡•á‡§ú‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§§‡•à‡§Ø‡§æ‡§∞‡•§ ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è '‡§≠‡•á‡§ú‡•á‡§Ç' ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§",
                voiceStatusError: "‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
                transcriptionPlaceholder: "‡§Ü‡§™‡§ï‡§æ ‡§≠‡§æ‡§∑‡§£ ‡§Ø‡§π‡§æ‡§Å ‡§¶‡§ø‡§ñ‡§æ‡§à ‡§¶‡•á‡§ó‡§æ...",
                errorNoMessage: "‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç",
                textMode: "üí¨ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•ã‡§°",
                speechMode: "üé§ ‡§∏‡•ç‡§™‡•Ä‡§ö ‡§Æ‡•ã‡§°",
                stopBotResponses: "üîá ‡§¨‡•â‡§ü ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ‡§è‡§Å ‡§∞‡•ã‡§ï‡•á‡§Ç",
                resumeBotResponses: "üîä ‡§¨‡•â‡§ü ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ‡§è‡§Å ‡§™‡•Å‡§®‡§É ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
                stopBotResponseButtonText: "‡§¨‡•â‡§ü ‡§ï‡•ã ‡§¨‡•ã‡§≤‡§®‡§æ ‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç"
            },
            mr: {
                welcome: "üëã ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§Ü‡§π‡•á! ‡§Æ‡•Ä Indicore AI, ‡§§‡•Å‡§Æ‡§ö‡§æ ‡§¨‡§π‡•Å‡§≠‡§æ‡§∑‡•Ä AI ‡§∏‡§π‡§æ‡§Ø‡•ç‡§Ø‡§ï ‡§Ü‡§π‡•á‡•§ ‡§á‡§ö‡•ç‡§õ‡§ø‡§§ ‡§≠‡§æ‡§∑‡§æ ‡§®‡§ø‡§µ‡§°‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§ú ‡§â‡§ò‡§°‡§æ‡•§",
                settings: "‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§ú",
                model: "AI ‡§Æ‡•â‡§°‡•á‡§≤",
                systemPrompt: "‡§∏‡§ø‡§∏‡•ç‡§ü‡§Æ ‡§∏‡•Ç‡§ö‡§®‡§æ",
                inputPlaceholder: "‡§§‡•Å‡§Æ‡§ö‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§Ø‡•á‡§•‡•á ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ...",
                send: "‡§™‡§æ‡§†‡§µ‡§æ",
                powered: "‡§á‡§Ç‡§°‡§ø‡§ï ‡§≠‡§æ‡§∑‡§æ‡§Ç‡§Æ‡§ß‡•ç‡§Ø‡•á ‡§∏‡§π ‡§ö‡§æ‡§≤‡§µ‡§≤‡•á‡§≤‡•á",
                language: "‡§≠‡§æ‡§∑‡§æ",
                close: "‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡§æ",
               
                languageName: "Marathi",
                voiceInput: "‡§Ü‡§µ‡§æ‡§ú ‡§á‡§®‡§™‡•Å‡§ü",
                startListening: "‡§ê‡§ï‡§£‡•á ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§æ",
                stopListening: "‡§ê‡§ï‡§£‡•á ‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡§æ",
                voiceStatusStart: "‡§¨‡•ã‡§≤‡§£‡•á ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä \"‡§ê‡§ï‡§£‡•á ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§æ\" ‡§µ‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§æ...",
                voiceStatusListening: "‡§ê‡§ï‡§§ ‡§Ü‡§π‡•á... ‡§Ü‡§§‡§æ ‡§¨‡•ã‡§≤‡§æ‡•§",
                voiceStatusReady: "‡§™‡§æ‡§†‡§µ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§§‡§Ø‡§æ‡§∞‡•§ ‡§∏‡•Å‡§∞‡•Ç ‡§†‡•á‡§µ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä '‡§™‡§æ‡§†‡§µ‡§æ' ‡§µ‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§æ‡•§",
                voiceStatusError: "‡§§‡•ç‡§∞‡•Å‡§ü‡•Ä ‡§ù‡§æ‡§≤‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ‡•§",
                transcriptionPlaceholder: "‡§§‡•Å‡§Æ‡§ö‡•á ‡§≠‡§æ‡§∑‡§£ ‡§Ø‡•á‡§•‡•á ‡§¶‡§ø‡§∏‡•á‡§≤...",
                errorNoMessage: "‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§æ",
                textMode: "üí¨ ‡§Æ‡§ú‡§ï‡•Ç‡§∞ ‡§Æ‡•ã‡§°",
                speechMode: "üé§ ‡§∏‡•ç‡§™‡•Ä‡§ö ‡§Æ‡•ã‡§°",
                stopBotResponses: "üîá ‡§¨‡•â‡§ü ‡§™‡•ç‡§∞‡§§‡§ø‡§∏‡§æ‡§¶ ‡§•‡§æ‡§Ç‡§¨‡§µ‡§æ",
                resumeBotResponses: "üîä ‡§¨‡•â‡§ü ‡§™‡•ç‡§∞‡§§‡§ø‡§∏‡§æ‡§¶ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§æ",
                stopBotResponseButtonText: "‡§¨‡•â‡§ü‡§≤‡§æ ‡§¨‡•ã‡§≤‡§£‡•á ‡§•‡§æ‡§Ç‡§¨‡§µ‡§æ"
            },
            ta: {
                welcome: "üëã ‡Æµ‡Æ∞‡Æµ‡Øá‡Æ±‡Øç‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç! ‡Æ®‡Ææ‡Æ©‡Øç Indicore AI, ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Æ≤‡Øç‡ÆÆ‡Øä‡Æ¥‡Æø AI ‡Æâ‡Æ§‡Æµ‡Æø‡ÆØ‡Ææ‡Æ≥‡Æ∞‡Øç‡•§ ‡Æµ‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡Æø‡ÆØ ‡ÆÆ‡Øä‡Æ¥‡Æø‡ÆØ‡Øà‡Æ§‡Øç ‡Æ§‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï ‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øà‡Æ§‡Øç ‡Æ§‡Æø‡Æ±‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç‡•§",
                settings: "‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç",
                model: "AI ‡ÆÆ‡Ææ‡Æ§‡Æø‡Æ∞‡Æø",
                systemPrompt: "‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ",
                inputPlaceholder: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø‡ÆØ‡Øà ‡Æá‡Æô‡Øç‡Æï‡Øá ‡Æ§‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç...",
                send: "‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ",
                powered: "‡Æá‡Æ®‡Øç‡Æ§‡Æø‡ÆØ ‡ÆÆ‡Øä‡Æ¥‡Æø‡Æï‡Æ≥‡Øç ‡Æâ‡Æü‡Æ©‡Øç ‡Æá‡ÆØ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ",
                language: "‡ÆÆ‡Øä‡Æ¥‡Æø",
                close: "‡ÆÆ‡ØÇ‡Æü‡ØÅ",
        
                languageName: "Tamil",
                voiceInput: "‡Æï‡ØÅ‡Æ∞‡Æ≤‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÄ‡Æü‡ØÅ",
                startListening: "‡Æï‡Øá‡Æü‡Øç‡Æï ‡ÆÜ‡Æ∞‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç",
                stopListening: "‡Æï‡Øá‡Æü‡Øç‡Æ™‡Æ§‡Øà ‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç",
                voiceStatusStart: "‡Æ™‡Øá‡Æö‡Æ§‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï \"‡Æï‡Øá‡Æü‡Øç‡Æï ‡ÆÜ‡Æ∞‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç\" ‡Æé‡Æ©‡Øç‡Æ™‡Æ§‡Øà‡Æï‡Øç ‡Æï‡Æø‡Æ≥‡Æø‡Æï‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç...",
                voiceStatusListening: "‡Æï‡Øá‡Æü‡Øç‡Æï‡Æø‡Æ±‡Æ§‡ØÅ... ‡Æá‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ ‡Æ™‡Øá‡Æö‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç‡•§",
                voiceStatusReady: "‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™ ‡Æ§‡ÆØ‡Ææ‡Æ∞‡Øç. ‡Æ§‡Øä‡Æü‡Æ∞ '‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ' ‡Æé‡Æ©‡Øç‡Æ™‡Æ§‡Øà‡Æï‡Øç ‡Æï‡Æø‡Æ≥‡Æø‡Æï‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç‡•§",
                voiceStatusError: "‡Æ™‡Æø‡Æ¥‡Øà ‡Æè‡Æ±‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ. ‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç‡•§",
                transcriptionPlaceholder: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Øá‡Æö‡Øç‡Æö‡ØÅ ‡Æá‡Æô‡Øç‡Æï‡Øá ‡Æ§‡Øã‡Æ©‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç...",
                errorNoMessage: "‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æí‡Æ∞‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø‡ÆØ‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç",
                textMode: "üí¨ ‡Æâ‡Æ∞‡Øà ‡ÆÆ‡ØÅ‡Æ±‡Øà",
                speechMode: "üé§ ‡Æ™‡Øá‡Æö‡Øç‡Æö‡ØÅ ‡ÆÆ‡ØÅ‡Æ±‡Øà",
                stopBotResponses: "üîá ‡Æ™‡Ææ‡Æü‡Øç ‡Æ™‡Æ§‡Æø‡Æ≤‡Øç‡Æï‡Æ≥‡Øà ‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ",
                resumeBotResponses: "üîä ‡Æ™‡Ææ‡Æü‡Øç ‡Æ™‡Æ§‡Æø‡Æ≤‡Øç‡Æï‡Æ≥‡Øà ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡ØÅ",
                stopBotResponseButtonText: "‡Æ™‡Ææ‡Æü‡Øç ‡Æ™‡Øá‡Æö‡ØÅ‡Æµ‡Æ§‡Øà ‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ"
            },
            bn: {
                welcome: "üëã ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ! ‡¶Ü‡¶Æ‡¶ø Indicore AI, ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶π‡ßÅ‡¶≠‡¶æ‡¶∑‡¶ø‡¶ï AI ‡¶∏‡¶π‡¶ï‡¶æ‡¶∞‡ßÄ‡•§ ‡¶™‡¶õ‡¶®‡ßç‡¶¶‡¶∏‡¶á ‡¶≠‡¶æ‡¶∑‡¶æ ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏ ‡¶ñ‡ßÅ‡¶≤‡ßÅ‡¶®‡•§",
                settings: "‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏",
                model: "AI ‡¶Æ‡¶°‡ßá‡¶≤",
                systemPrompt: "‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶™‡ßç‡¶∞‡¶Æ‡ßç‡¶™‡¶ü",
                inputPlaceholder: "‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßÅ‡¶®...",
                send: "‡¶™‡¶æ‡¶†‡¶æ‡¶®",
                powered: "‡¶á‡¶®‡ßç‡¶°‡¶ø‡¶ï ‡¶≠‡¶æ‡¶∑‡¶æ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶ö‡¶æ‡¶≤‡¶ø‡¶§",
                language: "‡¶≠‡¶æ‡¶∑‡¶æ",
                close: "‡¶¨‡¶®‡ßç‡¶ß",
                
                languageName: "Bengali",
                voiceInput: "‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶á‡¶®‡¶™‡ßÅ‡¶ü",
                startListening: "‡¶∂‡ßã‡¶®‡¶æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®",
                stopListening: "‡¶∂‡ßã‡¶®‡¶æ ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®",
                voiceStatusStart: "‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡¶æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶§‡ßá \"‡¶∂‡ßã‡¶®‡¶æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®\" ‡¶è ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®...",
                voiceStatusListening: "‡¶∂‡ßÅ‡¶®‡¶õ‡ßá... ‡¶è‡¶ñ‡¶® ‡¶¨‡¶≤‡ßÅ‡¶®‡•§",
                voiceStatusReady: "‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§‡•§ ‡¶ö‡¶æ‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡ßá‡¶§‡ßá '‡¶™‡¶æ‡¶†‡¶æ‡¶®' ‡¶è ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
                voiceStatusError: "‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶ò‡¶ü‡ßá‡¶õ‡ßá‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
                transcriptionPlaceholder: "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶ï‡ßç‡¶§‡ßÉ‡¶§‡¶æ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶¶‡¶∞‡ßç‡¶∂‡¶ø‡¶§ ‡¶π‡¶¨‡ßá...",
                errorNoMessage: "‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®",
                textMode: "üí¨ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶Æ‡ßã‡¶°",
                speechMode: "üé§ ‡¶∏‡ßç‡¶™‡¶ø‡¶ö ‡¶Æ‡ßã‡¶°",
                stopBotResponses: "üîá ‡¶¨‡¶ü ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®",
                resumeBotResponses: "üîä ‡¶¨‡¶ü ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡¶Ø‡¶º ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®",
                stopBotResponseButtonText: "‡¶¨‡¶ü‡¶ï‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡¶æ ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®"
            },
            pa: {
                welcome: "üëã ‡®ú‡©Ä ‡®Ü‡®á‡®Ü‡®Ç ‡®®‡©Ç‡©∞! ‡®Æ‡©à‡®Ç Indicore AI, ‡®§‡©Å‡®π‡®æ‡®°‡®æ ‡®¨‡®π‡©Å-‡®≠‡®æ‡®∏‡®º‡©Ä AI ‡®∏‡®π‡®æ‡®á‡®ï ‡®π‡®æ‡®Ç‡•§ ‡®≤‡©ã‡©ú‡©Ä‡®Ç‡®¶‡©Ä ‡®≠‡®æ‡®∏‡®º‡®æ ‡®ö‡©Å‡®£‡®® ‡®≤‡®à ‡®∏‡©à‡®ü‡®ø‡©∞‡®ó‡®æ‡®Ç ‡®ñ‡©ã‡®≤‡©ç‡®π‡©ã‡•§",
                settings: "‡®∏‡©à‡®ü‡®ø‡©∞‡®ó‡®æ‡®Ç",
                model: "AI ‡®Æ‡®æ‡®°‡®≤",
                systemPrompt: "‡®∏‡®ø‡®∏‡®ü‡®Æ ‡®™‡©ç‡®∞‡©ã‡®Æ‡®™‡®ü",
                inputPlaceholder: "‡®Ü‡®™‡®£‡®æ ‡®∏‡©Å‡®®‡©á‡®π‡®æ ‡®á‡©±‡®•‡©á ‡®≤‡®ø‡®ñ‡©ã...",
                send: "‡®≠‡©á‡®ú‡©ã",
                powered: "‡®á‡©∞‡®°‡®ø‡®ï ‡®≠‡®æ‡®∏‡®º‡®æ‡®µ‡®æ‡®Ç ‡®®‡®æ‡®≤ ‡®∏‡©∞‡®ö‡®æ‡®≤‡®ø‡®§",
                language: "‡®≠‡®æ‡®∏‡®º‡®æ",
                close: "‡®¨‡©∞‡®¶ ‡®ï‡®∞‡©ã",
                
                languageName: "Punjabi",
                voiceInput: "‡®Ü‡®µ‡®æ‡®ú‡®º ‡®á‡®®‡®™‡©Å‡®ü",
                startListening: "‡®∏‡©Å‡®£‡®®‡®æ ‡®∏‡®º‡©Å‡®∞‡©Ç ‡®ï‡®∞‡©ã",
                stopListening: "‡®∏‡©Å‡®£‡®®‡®æ ‡®¨‡©∞‡®¶ ‡®ï‡®∞‡©ã",
                voiceStatusStart: "‡®¨‡©ã‡®≤‡®£‡®æ ‡®∏‡®º‡©Å‡®∞‡©Ç ‡®ï‡®∞‡®® ‡®≤‡®à \"‡®∏‡©Å‡®£‡®®‡®æ ‡®∏‡®º‡©Å‡®∞‡©Ç ‡®ï‡®∞‡©ã\" ‡®§‡©á ‡®ï‡®≤‡®ø‡©±‡®ï ‡®ï‡®∞‡©ã...",
                voiceStatusListening: "‡®∏‡©Å‡®£ ‡®∞‡®ø‡®π‡®æ ‡®π‡©à... ‡®π‡©Å‡®£ ‡®¨‡©ã‡®≤‡©ã‡•§",
                voiceStatusReady: "‡®≠‡©á‡®ú‡®£ ‡®≤‡®à ‡®§‡®ø‡®Ü‡®∞‡•§ ‡®ú‡®æ‡®∞‡©Ä ‡®∞‡©±‡®ñ‡®£ ‡®≤‡®à '‡®≠‡©á‡®ú‡©ã' ‡®§‡©á ‡®ï‡®≤‡®ø‡©±‡®ï ‡®ï‡®∞‡©ã‡•§",
                voiceStatusError: "‡®ó‡®≤‡®§‡©Ä ‡®π‡©ã‡®à‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®¶‡©Å‡®¨‡®æ‡®∞‡®æ ‡®ï‡©ã‡®∏‡®º‡®ø‡®∏‡®º ‡®ï‡®∞‡©ã‡•§",
                transcriptionPlaceholder: "‡®§‡©Å‡®π‡®æ‡®°‡®æ ‡®≠‡®æ‡®∏‡®º‡®£ ‡®á‡©±‡®•‡©á ‡®¶‡®ø‡®ñ‡®æ‡®à ‡®¶‡©á‡®µ‡©á‡®ó‡®æ...",
                errorNoMessage: "‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®á‡©±‡®ï ‡®∏‡©Å‡®®‡©á‡®π‡®æ ‡®¶‡®∞‡®ú ‡®ï‡®∞‡©ã",
                textMode: "üí¨ ‡®ü‡©à‡®ï‡®∏‡®ü ‡®Æ‡©ã‡®°",
                speechMode: "üé§ ‡®∏‡®™‡©Ä‡®ö ‡®Æ‡©ã‡®°",
                stopBotResponses: "üîá ‡®¨‡©ã‡®ü ‡®™‡©ç‡®∞‡®§‡©Ä‡®ï‡®ø‡®∞‡®ø‡®Ü ‡®∞‡©ã‡®ï‡©ã",
                resumeBotResponses: "üîä ‡®¨‡©ã‡®ü ‡®™‡©ç‡®∞‡®§‡©Ä‡®ï‡®ø‡®∞‡®ø‡®Ü ‡®Æ‡©Å‡©ú ‡®ö‡®æ‡®≤‡©Ç ‡®ï‡®∞‡©ã",
                stopBotResponseButtonText: "‡®¨‡©ã‡®ü ‡®®‡©Ç‡©∞ ‡®¨‡©ã‡®≤‡®£‡®æ ‡®¨‡©∞‡®¶ ‡®ï‡®∞‡©ã"
            },
            gu: {
                welcome: "üëã ‡™∏‡´ç‡™µ‡™æ‡™ó‡™§ ‡™õ‡´á! ‡™π‡´Å‡™Ç Indicore AI, ‡™§‡™Æ‡™æ‡™∞‡´ã ‡™¨‡™π‡´Å‡™≠‡™æ‡™∑‡´Ä AI ‡™∏‡™π‡™æ‡™Ø‡™ï ‡™õ‡´Å‡™Ç‡•§ ‡™á‡™ö‡´ç‡™õ‡™ø‡™§ ‡™≠‡™æ‡™∑‡™æ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡™µ‡™æ ‡™Æ‡™æ‡™ü‡´á ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™ñ‡´ã‡™≤‡´ã‡•§",
                settings: "‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏",
                model: "AI ‡™Æ‡´ã‡™°‡´á‡™≤",
                systemPrompt: "‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ ‡™™‡´ç‡™∞‡´ã‡™Æ‡´ç‡™™‡´ç‡™ü",
                inputPlaceholder: "‡™§‡™Æ‡™æ‡™∞‡´ã ‡™∏‡™Ç‡™¶‡´á‡™∂ ‡™Ö‡™π‡´Ä‡™Ç ‡™≤‡™ñ‡´ã...",
                send: "‡™Æ‡´ã‡™ï‡™≤‡´ã",
                powered: "‡™á‡™®‡´ç‡™°‡™ø‡™ï ‡™≠‡™æ‡™∑‡™æ‡™ì ‡™∏‡™æ‡™•‡´á ‡™∏‡™Ç‡™ö‡™æ‡™≤‡™ø‡™§",
                language: "‡™≠‡™æ‡™∑‡™æ",
                close: "‡™¨‡™Ç‡™ß ‡™ï‡™∞‡´ã",
              
                languageName: "Gujarati",
                voiceInput: "‡™µ‡´â‡™á‡™∏ ‡™á‡™®‡™™‡´Å‡™ü",
                startListening: "‡™∏‡™æ‡™Ç‡™≠‡™≥‡™µ‡™æ‡™®‡´Å‡™Ç ‡™∂‡™∞‡´Ç ‡™ï‡™∞‡´ã",
                stopListening: "‡™∏‡™æ‡™Ç‡™≠‡™≥‡™µ‡™æ‡™®‡´Å‡™Ç ‡™¨‡™Ç‡™ß ‡™ï‡™∞‡´ã",
                voiceStatusStart: "‡™¨‡´ã‡™≤‡™µ‡™æ‡™®‡´Å‡™Ç ‡™∂‡™∞‡´Ç ‡™ï‡™∞‡™µ‡™æ ‡™Æ‡™æ‡™ü‡´á \"‡™∏‡™æ‡™Ç‡™≠‡™≥‡™µ‡™æ‡™®‡´Å‡™Ç ‡™∂‡™∞‡´Ç ‡™ï‡™∞‡´ã\" ‡™™‡™∞ ‡™ï‡´ç‡™≤‡™ø‡™ï ‡™ï‡™∞‡´ã...",
                voiceStatusListening: "‡™∏‡™æ‡™Ç‡™≠‡™≥‡´Ä ‡™∞‡™π‡´ç‡™Ø‡´Å‡™Ç ‡™õ‡´á... ‡™π‡™µ‡´á ‡™¨‡´ã‡™≤‡´ã‡•§",
                voiceStatusReady: "‡™Æ‡´ã‡™ï‡™≤‡™µ‡™æ ‡™Æ‡™æ‡™ü‡´á ‡™§‡´à‡™Ø‡™æ‡™∞‡•§ ‡™ö‡™æ‡™≤‡´Å ‡™∞‡™æ‡™ñ‡™µ‡™æ ‡™Æ‡™æ‡™ü‡´á '‡™Æ‡´ã‡™ï‡™≤‡´ã' ‡™™‡™∞ ‡™ï‡´ç‡™≤‡™ø‡™ï ‡™ï‡™∞‡´ã‡•§",
                voiceStatusError: "‡™≠‡´Ç‡™≤ ‡™•‡™à. ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™´‡™∞‡´Ä‡™•‡´Ä ‡™™‡´ç‡™∞‡™Ø‡™æ‡™∏ ‡™ï‡™∞‡´ã‡•§",
                transcriptionPlaceholder: "‡™§‡™Æ‡™æ‡™∞‡´Å‡™Ç ‡™≠‡™æ‡™∑‡™£ ‡™Ö‡™π‡´Ä‡™Ç ‡™¶‡´á‡™ñ‡™æ‡™∂‡´á...",
                errorNoMessage: "‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™è‡™ï ‡™∏‡™Ç‡™¶‡´á‡™∂ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã",
                textMode: "üí¨ ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü ‡™Æ‡´ã‡™°",
                speechMode: "üé§ ‡™∏‡´ç‡™™‡´Ä‡™ö ‡™Æ‡´ã‡™°",
                stopBotResponses: "üîá ‡™¨‡´ã‡™ü ‡™™‡´ç‡™∞‡™§‡™ø‡™∏‡™æ‡™¶ ‡™∞‡´ã‡™ï‡´ã",
                resumeBotResponses: "üîä ‡™¨‡´ã‡™ü ‡™™‡´ç‡™∞‡™§‡™ø‡™∏‡™æ‡™¶ ‡™´‡™∞‡´Ä ‡™∂‡™∞‡´Ç ‡™ï‡™∞‡´ã",
                stopBotResponseButtonText: "‡™¨‡´ã‡™ü‡™®‡´á ‡™¨‡´ã‡™≤‡™µ‡™æ‡™®‡´Å‡™Ç ‡™¨‡™Ç‡™ß ‡™ï‡™∞‡´ã"
            },
            te: {
                welcome: "üëã ‡∞∏‡±ç‡∞µ‡∞æ‡∞ó‡∞§‡∞Ç! ‡∞®‡±á‡∞®‡±Å ‡∞á‡∞Ç‡∞°‡∞ø‡∞ï‡±ã‡∞∞‡±ç AI, ‡∞Æ‡±Ä ‡∞¨‡∞π‡±Å‡∞≠‡∞æ‡∞∑‡∞æ AI ‡∞∏‡∞π‡∞æ‡∞Ø‡∞ï‡±Å‡∞°‡∞ø‡∞®‡∞ø. ‡∞Æ‡±Ä‡∞ï‡±Å ‡∞ï‡∞æ‡∞µ‡∞≤‡∞∏‡∞ø‡∞® ‡∞≠‡∞æ‡∞∑‡∞®‡±Å ‡∞é‡∞Ç‡∞ö‡±Å‡∞ï‡±ã‡∞µ‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞∏‡±Ü‡∞ü‡±ç‡∞ü‡∞ø‡∞Ç‡∞ó‡±ç‡∞∏‡±ç ‡∞§‡±Ü‡∞∞‡∞µ‡∞Ç‡∞°‡∞ø.",
                settings: "‡∞∏‡±Ü‡∞ü‡±ç‡∞ü‡∞ø‡∞Ç‡∞ó‡±ç‡∞∏‡±ç",
                model: "AI ‡∞Æ‡±ã‡∞°‡∞≤‡±ç",
                systemPrompt: "‡∞∏‡∞ø‡∞∏‡±ç‡∞ü‡∞Æ‡±ç ‡∞™‡±ç‡∞∞‡∞æ‡∞Ç‡∞™‡±ç‡∞ü‡±ç",
                inputPlaceholder: "‡∞Æ‡±Ä ‡∞∏‡∞Ç‡∞¶‡±á‡∞∂‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞á‡∞ï‡±ç‡∞ï‡∞° ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø...",
                send: "‡∞™‡∞Ç‡∞™‡∞ø‡∞Ç‡∞ö‡±Å",
                powered: "‡∞á‡∞Ç‡∞°‡∞ø‡∞ï‡±ç ‡∞≠‡∞æ‡∞∑‡∞≤‡∞§‡±ã ‡∞®‡∞°‡±Å‡∞™‡∞¨‡∞°‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø",
                language: "‡∞≠‡∞æ‡∞∑",
                close: "‡∞Æ‡±Ç‡∞∏‡∞ø‡∞µ‡±á‡∞Ø‡∞ø",
                
                languageName: "Telugu",
                voiceInput: "‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞á‡∞®‡±ç‡∞™‡±Å‡∞ü‡±ç",
                startListening: "‡∞µ‡∞ø‡∞®‡∞°‡∞Ç ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
                stopListening: "‡∞µ‡∞ø‡∞®‡∞°‡∞Ç ‡∞Ü‡∞™‡∞Ç‡∞°‡∞ø",
                voiceStatusStart: "‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞ü‡∞Ç ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø \"‡∞µ‡∞ø‡∞®‡∞°‡∞Ç ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø\"‡∞™‡±à ‡∞ï‡±ç‡∞≤‡∞ø‡∞ï‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø...",
                voiceStatusListening: "‡∞µ‡∞ø‡∞Ç‡∞ü‡±ã‡∞Ç‡∞¶‡∞ø... ‡∞á‡∞™‡±ç‡∞™‡±Å‡∞°‡±Å ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø.",
                voiceStatusReady: "‡∞™‡∞Ç‡∞™‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞∏‡∞ø‡∞¶‡±ç‡∞ß‡∞Ç‡∞ó‡∞æ ‡∞â‡∞Ç‡∞¶‡∞ø. ‡∞ï‡±ä‡∞®‡∞∏‡∞æ‡∞ó‡∞ø‡∞Ç‡∞ö‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø '‡∞™‡∞Ç‡∞™‡∞ø‡∞Ç‡∞ö‡±Å'‡∞™‡±à ‡∞ï‡±ç‡∞≤‡∞ø‡∞ï‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø.",
                voiceStatusError: "‡∞≤‡±ã‡∞™‡∞Ç ‡∞∏‡∞Ç‡∞≠‡∞µ‡∞ø‡∞Ç‡∞ö‡∞ø‡∞Ç‡∞¶‡∞ø. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø.",
                transcriptionPlaceholder: "‡∞Æ‡±Ä ‡∞Æ‡∞æ‡∞ü‡∞≤‡±Å ‡∞á‡∞ï‡±ç‡∞ï‡∞° ‡∞ï‡∞®‡∞ø‡∞™‡∞ø‡∞∏‡±ç‡∞§‡∞æ‡∞Ø‡∞ø...",
                errorNoMessage: "‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞í‡∞ï ‡∞∏‡∞Ç‡∞¶‡±á‡∞∂‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
                textMode: "üí¨ ‡∞ü‡±Ü‡∞ï‡±ç‡∞∏‡±ç‡∞ü‡±ç ‡∞Æ‡±ã‡∞°‡±ç",
                speechMode: "üé§ ‡∞∏‡±ç‡∞™‡±Ä‡∞ö‡±ç ‡∞Æ‡±ã‡∞°‡±ç",
                stopBotResponses: "üîá ‡∞¨‡∞æ‡∞ü‡±ç ‡∞™‡±ç‡∞∞‡∞§‡∞ø‡∞∏‡±ç‡∞™‡∞Ç‡∞¶‡∞®‡∞≤‡±Å ‡∞Ü‡∞™‡±Å",
                resumeBotResponses: "üîä ‡∞¨‡∞æ‡∞ü‡±ç ‡∞™‡±ç‡∞∞‡∞§‡∞ø‡∞∏‡±ç‡∞™‡∞Ç‡∞¶‡∞®‡∞≤‡±Å ‡∞™‡±Å‡∞®‡∞É‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡±Å",
                stopBotResponseButtonText: "‡∞¨‡∞æ‡∞ü‡±ç ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞ü‡∞Ç ‡∞Ü‡∞™‡±Å"
            },
            ml: {
                welcome: "üëã ‡¥∏‡µç‡¥µ‡¥æ‡¥ó‡¥§‡¥Ç! ‡¥û‡¥æ‡µª ‡¥á‡µª‡¥°‡¥ø‡¥ï‡µç‡¥ï‡µã‡µº AI, ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥¨‡¥π‡µÅ‡¥≠‡¥æ‡¥∑‡¥æ AI ‡¥∏‡¥π‡¥æ‡¥Ø‡¥ø‡¥Ø‡¥æ‡¥£‡µç. ‡¥Ü‡¥µ‡¥∂‡µç‡¥Ø‡¥Æ‡µÅ‡¥≥‡µç‡¥≥ ‡¥≠‡¥æ‡¥∑ ‡¥§‡¥ø‡¥∞‡¥û‡µç‡¥û‡µÜ‡¥ü‡µÅ‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥ï‡µç‡¥∞‡¥Æ‡µÄ‡¥ï‡¥∞‡¥£‡¥ô‡µç‡¥ô‡µæ ‡¥§‡µÅ‡¥±‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
                settings: "‡¥ï‡µç‡¥∞‡¥Æ‡µÄ‡¥ï‡¥∞‡¥£‡¥ô‡µç‡¥ô‡µæ",
                model: "AI ‡¥Æ‡µã‡¥°‡µΩ",
                systemPrompt: "‡¥∏‡¥ø‡¥∏‡µç‡¥±‡µç‡¥±‡¥Ç ‡¥™‡µç‡¥∞‡µã‡¥Ç‡¥™‡µç‡¥±‡µç‡¥±‡µç",
                inputPlaceholder: "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥∏‡¥®‡µç‡¥¶‡µá‡¥∂‡¥Ç ‡¥á‡¥µ‡¥ø‡¥ü‡µÜ ‡¥ü‡µà‡¥™‡µç‡¥™‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï...",
                send: "‡¥Ö‡¥Ø‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
                powered: "‡¥á‡µª‡¥°‡¥ø‡¥ï‡µç ‡¥≠‡¥æ‡¥∑‡¥ï‡¥≥‡¥æ‡µΩ ‡¥™‡µç‡¥∞‡¥µ‡µº‡¥§‡µç‡¥§‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡µç",
                language: "‡¥≠‡¥æ‡¥∑",
                close: "‡¥Ö‡¥ü‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
                
                languageName: "Malayalam",
                voiceInput: "‡¥µ‡µã‡¥Ø‡µç‚Äå‡¥∏‡µç ‡¥á‡µª‡¥™‡µÅ‡¥ü‡µç‡¥ü‡µç",
                startListening: "‡¥ï‡µá‡µæ‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥§‡µÅ‡¥ü‡¥ô‡µç‡¥ô‡µÅ‡¥ï",
                stopListening: "‡¥ï‡µá‡µæ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡µç ‡¥®‡¥ø‡µº‡¥§‡µç‡¥§‡µÅ‡¥ï",
                voiceStatusStart: "‡¥∏‡¥Ç‡¥∏‡¥æ‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥§‡µÅ‡¥ü‡¥ô‡µç‡¥ô‡¥æ‡µª \"‡¥ï‡µá‡µæ‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥§‡µÅ‡¥ü‡¥ô‡µç‡¥ô‡µÅ‡¥ï\" ‡¥ï‡µç‡¥≤‡¥ø‡¥ï‡µç‡¥ï‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï...",
                voiceStatusListening: "‡¥ï‡µá‡µæ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ... ‡¥á‡¥™‡µç‡¥™‡µã‡µæ ‡¥∏‡¥Ç‡¥∏‡¥æ‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
                voiceStatusReady: "‡¥Ö‡¥Ø‡¥Ø‡µç‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥§‡¥Ø‡µç‡¥Ø‡¥æ‡¥±‡¥æ‡¥£‡µç. ‡¥§‡µÅ‡¥ü‡¥∞‡¥æ‡µª '‡¥Ö‡¥Ø‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥ï' ‡¥ï‡µç‡¥≤‡¥ø‡¥ï‡µç‡¥ï‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï.",
                voiceStatusError: "‡¥í‡¥∞‡µÅ ‡¥™‡¥ø‡¥∂‡¥ï‡µç ‡¥∏‡¥Ç‡¥≠‡¥µ‡¥ø‡¥ö‡µç‡¥ö‡µÅ. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥µ‡µÄ‡¥£‡µç‡¥ü‡µÅ‡¥Ç ‡¥∂‡µç‡¥∞‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
                transcriptionPlaceholder: "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥∏‡¥Ç‡¥∏‡¥æ‡¥∞‡¥Ç ‡¥á‡¥µ‡¥ø‡¥ü‡µÜ ‡¥¶‡µÉ‡¥∂‡µç‡¥Ø‡¥Æ‡¥æ‡¥ï‡µÅ‡¥Ç...",
                errorNoMessage: "‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥í‡¥∞‡µÅ ‡¥∏‡¥®‡µç‡¥¶‡µá‡¥∂‡¥Ç ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï",
                textMode: "üí¨ ‡¥ü‡µÜ‡¥ï‡µç‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥Æ‡µã‡¥°‡µç",
                speechMode: "üé§ ‡¥∏‡µç‡¥™‡µÄ‡¥ö‡µç‡¥ö‡µç ‡¥Æ‡µã‡¥°‡µç",
                stopBotResponses: "üîá ‡¥¨‡µã‡¥ü‡µç‡¥ü‡µç ‡¥™‡µç‡¥∞‡¥§‡¥ø‡¥ï‡¥∞‡¥£‡¥ô‡µç‡¥ô‡µæ ‡¥®‡¥ø‡µº‡¥§‡µç‡¥§‡µÅ‡¥ï",
                resumeBotResponses: "üîä ‡¥¨‡µã‡¥ü‡µç‡¥ü‡µç ‡¥™‡µç‡¥∞‡¥§‡¥ø‡¥ï‡¥∞‡¥£‡¥ô‡µç‡¥ô‡µæ ‡¥™‡µÅ‡¥®‡¥∞‡¥æ‡¥∞‡¥Ç‡¥≠‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
                stopBotResponseButtonText: "‡¥¨‡µã‡¥ü‡µç‡¥ü‡µç ‡¥∏‡¥Ç‡¥∏‡¥æ‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡µç ‡¥®‡¥ø‡µº‡¥§‡µç‡¥§‡µÅ‡¥ï"
            },
            kn: {
                welcome: "üëã ‡≤∏‡≥ç‡≤µ‡≤æ‡≤ó‡≤§! ‡≤®‡≤æ‡≤®‡≥Å ‡≤á‡≤Ç‡≤°‡≤ø‡≤ï‡≥ã‡≤∞‡≥ç AI, ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤¨‡≤π‡≥Å‡≤≠‡≤æ‡≤∑‡≤æ AI ‡≤∏‡≤π‡≤æ‡≤Ø‡≤ï. ‡≤¨‡≤Ø‡≤∏‡≤ø‡≤¶ ‡≤≠‡≤æ‡≤∑‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤Ü‡≤Ø‡≥ç‡≤ï‡≥Ü ‡≤Æ‡≤æ‡≤°‡≤≤‡≥Å ‡≤∏‡≥Ü‡≤ü‡≥ç‡≤ü‡≤ø‡≤Ç‡≤ó‡≥ç‡≤∏‡≥ç ‡≤§‡≥Ü‡≤∞‡≥Ü‡≤Ø‡≤ø‡≤∞‡≤ø.",
                settings: "‡≤∏‡≥Ü‡≤ü‡≥ç‡≤ü‡≤ø‡≤Ç‡≤ó‡≥ç‡≤∏‡≥ç",
                model: "AI ‡≤Æ‡≤æ‡≤¶‡≤∞‡≤ø",
                systemPrompt: "‡≤∏‡≤ø‡≤∏‡≥ç‡≤ü‡≤Æ‡≥ç ‡≤™‡≥ç‡≤∞‡≤æ‡≤Ç‡≤™‡≥ç‡≤ü‡≥ç",
                inputPlaceholder: "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤∏‡≤Ç‡≤¶‡≥á‡≤∂‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤á‡≤≤‡≥ç‡≤≤‡≤ø ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø...",
                send: "‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤ø",
                powered: "‡≤á‡≤Ç‡≤°‡≤ø‡≤ï‡≥ç ‡≤≠‡≤æ‡≤∑‡≥Ü‡≤ó‡≤≥‡≥ä‡≤Ç‡≤¶‡≤ø‡≤ó‡≥Ü ‡≤®‡≤°‡≥Ü‡≤∏‡≤≤‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü",
                language: "‡≤≠‡≤æ‡≤∑‡≥Ü",
                close: "‡≤Æ‡≥Å‡≤ö‡≥ç‡≤ö‡≤ø",
               
                languageName: "Kannada",
                voiceInput: "‡≤ß‡≥ç‡≤µ‡≤®‡≤ø ‡≤á‡≤®‡≥ç‡≤™‡≥Å‡≤ü‡≥ç",
                startListening: "‡≤ï‡≥á‡≤≥‡≤≤‡≥Å ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤ø",
                stopListening: "‡≤ï‡≥á‡≤≥‡≥Å‡≤µ‡≥Å‡≤¶‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤ø‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≤ø",
                voiceStatusStart: "‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤≤‡≥Å ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤≤‡≥Å \"‡≤ï‡≥á‡≤≥‡≤≤‡≥Å ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤ø\" ‡≤ï‡≥ç‡≤≤‡≤ø‡≤ï‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø...",
                voiceStatusListening: "‡≤ï‡≥á‡≤≥‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü... ‡≤à‡≤ó ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤ø.",
                voiceStatusReady: "‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤≤‡≥Å ‡≤∏‡≤ø‡≤¶‡≥ç‡≤ß‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤Æ‡≥Å‡≤Ç‡≤¶‡≥Å‡≤µ‡≤∞‡≤ø‡≤Ø‡≤≤‡≥Å '‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤ø' ‡≤ï‡≥ç‡≤≤‡≤ø‡≤ï‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø.",
                voiceStatusError: "‡≤í‡≤Ç‡≤¶‡≥Å ‡≤¶‡≥ã‡≤∑ ‡≤∏‡≤Ç‡≤≠‡≤µ‡≤ø‡≤∏‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.",
                transcriptionPlaceholder: "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤Æ‡≤æ‡≤§‡≥Å‡≤ó‡≤≥‡≥Å ‡≤á‡≤≤‡≥ç‡≤≤‡≤ø ‡≤ï‡≤æ‡≤£‡≤ø‡≤∏‡≥Å‡≤§‡≥ç‡≤§‡≤µ‡≥Ü...",
                errorNoMessage: "‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤í‡≤Ç‡≤¶‡≥Å ‡≤∏‡≤Ç‡≤¶‡≥á‡≤∂‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø",
                textMode: "üí¨ ‡≤™‡≤†‡≥ç‡≤Ø ‡≤Æ‡≥ã‡≤°‡≥ç",
                speechMode: "üé§ ‡≤≠‡≤æ‡≤∑‡≤£ ‡≤Æ‡≥ã‡≤°‡≥ç",
                stopBotResponses: "üîá ‡≤¨‡≤æ‡≤ü‡≥ç ‡≤™‡≥ç‡≤∞‡≤§‡≤ø‡≤ï‡≥ç‡≤∞‡≤ø‡≤Ø‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤ø‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≤ø",
                resumeBotResponses: "üîä ‡≤¨‡≤æ‡≤ü‡≥ç ‡≤™‡≥ç‡≤∞‡≤§‡≤ø‡≤ï‡≥ç‡≤∞‡≤ø‡≤Ø‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≥Å‡≤®‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤ø",
                stopBotResponseButtonText: "‡≤¨‡≤æ‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≥Å‡≤µ‡≥Å‡≤¶‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤ø‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≤ø"
            }
        };

        // Enhanced Azure language mapping
        const azureLanguageMap = {
            'en': 'en-IN',
            'hi': 'hi-IN',
            'mr': 'mr-IN',
            'ta': 'ta-IN',
            'bn': 'bn-IN',
            'pa': 'pa-IN',
            'gu': 'gu-IN',
            'te': 'te-IN',
            'ml': 'ml-IN',
            'kn': 'kn-IN',
            'es': 'es-ES'
        };

        // Azure Speech Synthesis Voice Mapping
        const azureVoiceMap = {
             'en': 'en-IN-NeerjaNeural', // English (India) - Female
             'hi': 'hi-IN-MadhurNeural', // Hindi (India) - Male
             'mr': 'mr-IN-AarohiNeural', // Marathi (India) - Female
             'ta': 'ta-IN-PallaviNeural', // Tamil (India) - Male
             'bn': 'bn-IN-TanishaaNeural', // Bengali (India) - Female
             'pa': 'pa-IN-OjasNeural', // Punjabi (India) - Female
             'gu': 'gu-IN-NiranjanNeural', // Gujarati (India) - Female
             'te': 'te-IN-MohanNeural', // Telugu (India) - Female
             'ml': 'ml-IN-MidhunNeural', // Malayalam (India) - Female
             'kn': 'kn-IN-GaganNeural' ,// Kannada (India) - Male
             'es': 'es-ES-ElviraNeural'   // Spanish (Spain) - Female
        };

        // Model descriptions
        const modelDescriptions = {
            'sonar-pro': 'Advanced search-enabled model with comprehensive answers',
            'sonar': 'Balanced model with web search capabilities',
            'sonar-small': 'Fast model with basic web search',
            'mistral-7b-instruct': 'Open-source model balanced for various tasks',
            'codellama-34b-instruct': 'Specialized for code-related tasks',
            'llama-2-70b-chat': 'Large model with broad knowledge capabilities'
        };

        // Voice input setup
        const micButton = document.getElementById('micButton');
        const voiceDialog = document.getElementById('voiceDialog');
        const closeDialog = document.getElementById('closeDialog');
        const startListening = document.getElementById('startListening');
        const stopListening = document.getElementById('stopListening');
        const sendVoiceMessage = document.getElementById('sendVoiceMessage');
        const voiceStatus = document.getElementById('voiceStatus');
        const transcription = document.getElementById('transcription');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        // const stopSpeechButton = document.getElementById('stopSpeechButton'); // Global stop speech button - REMOVED
        const stopBotResponseButtonDialog = document.getElementById('stopBotResponseButtonDialog'); // New stop bot response button in dialog
        const stopBotToggle = document.getElementById('stopBotToggle'); // The new toggle button in settings
        const chatContainer = document.querySelector('.chat-container');
        const modeToggle = document.getElementById('modeToggle');
        const mainLoadingIndicator = document.getElementById('loading');
        const voiceLoadingIndicator = document.getElementById('voiceLoadingIndicator');

        // Azure Speech Recognition setup
        let azureSpeechConfig = null;
        let azureRecognizer = null;
        let isListening = false;
        let finalTranscriptText = '';
        let isSpeaking = false; // Tracks if Azure TTS is currently speaking
        let azureSynthesizer = null; // Azure Speech Synthesizer instance
        let currentChatMode = 'text-to-text'; // Default mode
        let botResponsesStopped = false; // New state variable for stopping all bot responses

        // Azure Speech Recognition class
        class AzureSpeechRecognizer {
            constructor() {
                this.speechConfig = null;
                this.recognizer = null; // Will store the SpeechSDK.SpeechRecognizer instance
                this.isListening = false;
                this.finalTranscript = '';
            }

            initializeSpeechConfig() {
                try {
                    const lang = document.getElementById('languageSelect').value;
                    const azureLang = azureLanguageMap[lang] || 'en-IN';

                    this.speechConfig = SpeechSDK.SpeechConfig.fromSubscription(API_CONFIG.azure.key, API_CONFIG.azure.region);
                    this.speechConfig.speechRecognitionLanguage = azureLang;
                    this.speechConfig.outputFormat = SpeechSDK.OutputFormat.Detailed;
                    this.speechConfig.setProperty(
                        SpeechSDK.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs,
                        "5000"
                    );

                    return true;
                } catch (error) {
                    voiceStatus.textContent = `Configuration error: ${error.message}`;
                    console.error("Speech Recognition Config Error:", error);
                    return false;
                }
            }

            startRecognition() {
                if (!this.initializeSpeechConfig()) {
                    return;
                }

                try {
                    const audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
                    this.recognizer = new SpeechSDK.SpeechRecognizer(this.speechConfig, audioConfig);
                    this.finalTranscript = '';

                    this.recognizer.recognizing = (s, e) => {
                        this.displayInterimResult(e.result.text);
                    };

                    this.recognizer.recognized = (s, e) => {
                        if (e.result.reason === SpeechSDK.ResultReason.RecognizedSpeech) {
                            this.displayFinalResult(e.result.text);
                        } else if (e.result.reason === SpeechSDK.ResultReason.NoMatch) {
                            console.warn("Speech Recognition: No speech could be recognized.");
                        }
                    };

                    this.recognizer.canceled = (s, e) => {
                        this.handleError(e);
                    };

                    this.recognizer.sessionStopped = (s, e) => {
                        this.stopRecognition(); // This will be called when session naturally ends
                    };

                    this.recognizer.startContinuousRecognitionAsync(
                        () => {
                            this.isListening = true;
                            const lang = document.getElementById('languageSelect').value;
                            voiceStatus.textContent = translations[lang].voiceStatusListening;
                            startListening.disabled = true;
                            stopListening.disabled = false;
                            sendVoiceMessage.disabled = true; // Disable send until valid input
                            micButton.classList.add('recording');
                        },
                        (error) => {
                            voiceStatus.textContent = `Failed to start: ${error}`;
                            console.error("Speech Recognition Start Error:", error);
                            this.resetVoiceControls();
                        }
                    );

                } catch (error) {
                    voiceStatus.textContent = `Recognition error: ${error.message}`;
                    console.error("Speech Recognition Runtime Error:", error);
                    this.resetVoiceControls();
                }
            }

            stopRecognition() {
                if (this.recognizer && this.isListening) {
                    this.recognizer.stopContinuousRecognitionAsync(
                        () => {
                            this.isListening = false;
                            this.resetVoiceControls();
                            if (this.recognizer) {
                                this.recognizer.close();
                                this.recognizer = null;
                            }

                            if (this.finalTranscript.trim()) {
                                const lang = document.getElementById('languageSelect').value;
                                voiceStatus.textContent = translations[lang].voiceStatusReady;
                                sendVoiceMessage.disabled = false;
                            } else {
                                const lang = document.getElementById('languageSelect').value;
                                voiceStatus.textContent = translations[lang].voiceStatusStart;
                            }
                        },
                        (error) => {
                            voiceStatus.textContent = `Stop error: ${error}`;
                            console.error("Speech Recognition Stop Error:", error);
                            this.resetVoiceControls();
                            if (this.recognizer) {
                                this.recognizer.close();
                                this.recognizer = null;
                            }
                        }
                    );
                } else {
                    this.isListening = false;
                    this.resetVoiceControls();
                    this.recognizer = null;
                }
            }

            displayInterimResult(text) {
                if (text) {
                    transcription.textContent = this.finalTranscript + text;
                    transcription.style.fontStyle = 'italic';
                    transcription.style.color = '#666';
                }
            }

            displayFinalResult(text) {
                if (text) {
                    this.finalTranscript += text + ' ';
                    transcription.textContent = this.finalTranscript.trim();
                    transcription.style.fontStyle = 'normal';
                    transcription.style.color = '#333';
                    sendVoiceMessage.disabled = false;
                }
            }

            resetVoiceControls() {
                isListening = false;
                startListening.disabled = false;
                stopListening.disabled = true;
                micButton.classList.remove('recording');
            }

            handleError(e) {
                let errorMessage = 'Recognition error occurred';

                if (e.reason === SpeechSDK.CancellationReason.Error) {
                    errorMessage = `Error: ${e.errorDetails}`;
                    console.error(`Speech Recognition Canceled Error: ${e.errorDetails}`);
                } else if (e.reason === SpeechSDK.CancellationReason.EndOfStream) {
                    errorMessage = 'End of stream reached. No speech detected or timeout.';
                    console.warn("Speech Recognition: End of stream or no speech detected.");
                }

                voiceStatus.textContent = errorMessage;
                this.stopRecognition();
            }
        }

        // ADD THESE FUNCTIONS ANYWHERE IN YOUR SCRIPT SECTION

        function updateQuestionCounter() {
            totalQuestionsAsked++;
            sessionQuestionsAsked++;

            // Update display
            document.getElementById('questionCount').textContent = totalQuestionsAsked;
            document.getElementById('sessionQuestions').textContent = sessionQuestionsAsked;

            // Save to localStorage
            saveQuestionStats();
        }

        function loadQuestionStats() {
            const stats = localStorage.getItem('indicoreStats');
            if (stats) {
                const data = JSON.parse(stats);
                totalQuestionsAsked = data.totalQuestions || 0;
                sessionStartTime = Date.now();
                sessionQuestionsAsked = 0;
            }

            // Update display
            document.getElementById('questionCount').textContent = totalQuestionsAsked;
            document.getElementById('sessionQuestions').textContent = sessionQuestionsAsked;
        }

        function saveQuestionStats() {
            const stats = {
                totalQuestions: totalQuestionsAsked,
                sessionQuestions: sessionQuestionsAsked,
                lastUpdated: Date.now(),
                sessionStartTime: sessionStartTime
            };
            localStorage.setItem('indicoreStats', JSON.stringify(stats));
        }

        function resetQuestionCounter() {
            if (confirm('Are you sure you want to reset the question counter? This action cannot be undone.')) {
                totalQuestionsAsked = 0;
                sessionQuestionsAsked = 0;
                sessionStartTime = Date.now();

                document.getElementById('questionCount').textContent = '0';
                document.getElementById('sessionQuestions').textContent = '0';

                localStorage.removeItem('indicoreStats');

                addMessage('üìä Question counter has been reset successfully!', false);
            }
        }

        function exportStats() {
            const stats = {
                totalQuestions: totalQuestionsAsked,
                sessionQuestions: sessionQuestionsAsked,
                sessionDuration: Math.round((Date.now() - sessionStartTime) / (1000 * 60)),
                exportDate: new Date().toLocaleString(),
                language: document.getElementById('languageSelect').value,
                model: document.getElementById('modelSelect').value
            };

            const dataStr = JSON.stringify(stats, null, 2);
            const dataBlob = new Blob([dataStr], {
                type: 'application/json'
            });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `indicore-ai-stats-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            addMessage('üìã Statistics exported successfully!', false);
        }


        // Initialize Azure Speech Recognizer
        const azureSpeechRecognizer = new AzureSpeechRecognizer();

        function resetTranscription() {
            const lang = document.getElementById('languageSelect').value;
            transcription.textContent = translations[lang].transcriptionPlaceholder;
            transcription.style.fontStyle = 'italic';
            transcription.style.color = '#666';
            sendVoiceMessage.disabled = true;
        }

        // --- Azure Speech Synthesis (TTS) Implementation ---
        function initializeAzureSynthesizer() {
            if (azureSynthesizer) {
                azureSynthesizer.close(); // Close existing synthesizer if open
                azureSynthesizer = null;
            }
            try {
                const speechConfig = SpeechSDK.SpeechConfig.fromSubscription(API_CONFIG.azure.key, API_CONFIG.azure.region);
                speechConfig.setProfanity(SpeechSDK.ProfanityOption.Removed);

                azureSynthesizer = new SpeechSDK.SpeechSynthesizer(speechConfig);

                azureSynthesizer.SynthesisStarted = () => {
                    isSpeaking = true;
                    // stopSpeechButton.classList.add('show'); // This is the global button, likely no longer needed
                    stopBotResponseButtonDialog.style.display = 'block'; // Show dialog stop button
                    console.log('Azure speech synthesis started.');
                };

                azureSynthesizer.SynthesisCompleted = () => {
                    isSpeaking = false;
                    // stopSpeechButton.classList.remove('show');
                    stopBotResponseButtonDialog.style.display = 'none'; // Hide dialog stop button
                    console.log('Azure speech synthesis completed.');
                    if (azureSynthesizer) {
                        azureSynthesizer.close();
                        azureSynthesizer = null;
                    }
                    // Re-enable listening after speech completes in speech-to-speech mode, if bot is not stopped
                    if (currentChatMode === 'speech-to-speech' && voiceDialog.style.display === 'flex' && !botResponsesStopped) {
                        azureSpeechRecognizer.startRecognition();
                    }
                };

                azureSynthesizer.SynthesisCanceled = (s, e) => {
                    isSpeaking = false;
                    // stopSpeechButton.classList.remove('show');
                    stopBotResponseButtonDialog.style.display = 'none'; // Hide dialog stop button
                    console.error(`Azure speech synthesis canceled. Reason: ${e.reason}. Error details: ${e.errorDetails}. For more info: ${e.errorDetails}`);
                    if (azureSynthesizer) {
                        azureSynthesizer.close();
                        azureSynthesizer = null;
                    }
                    // Re-enable listening even if speech was canceled, if bot is not stopped
                    if (currentChatMode === 'speech-to-speech' && voiceDialog.style.display === 'flex' && !botResponsesStopped) {
                        azureSpeechRecognizer.startRecognition();
                    }
                };

                azureSynthesizer.SynthesisError = (s, e) => {
                    console.error(`Azure speech synthesis error event: ${e.errorDetails}`);
                    isSpeaking = false;
                    // stopSpeechButton.classList.remove('show');
                    stopBotResponseButtonDialog.style.display = 'none'; // Hide dialog stop button
                    // Re-enable listening on error, if bot is not stopped
                    if (currentChatMode === 'speech-to-speech' && voiceDialog.style.display === 'flex' && !botResponsesStopped) {
                        azureSpeechRecognizer.startRecognition();
                    }
                };

            } catch (error) {
                console.error("Error initializing Azure Speech Synthesizer:", error);
                alert("Failed to initialize speech synthesis. Check Azure Speech SDK and API config.");
            }
        }

        function speak(text, lang) {
            // Do not speak if bot responses are globally stopped
            if (botResponsesStopped) {
                console.log("Bot responses are stopped. Not speaking.");
                return;
            }

            if (isSpeaking) {
                stopSpeech(); // Stop any ongoing speech before starting a new one
            }

            if (!SpeechSDK) {
                console.error('Azure Speech SDK is not loaded. Cannot speak.');
                return;
            }

            if (!azureSynthesizer) {
                initializeAzureSynthesizer();
            }

            if (!azureSynthesizer) { // Check again if initialization failed
                console.error('Azure Speech Synthesizer could not be initialized. Cannot speak.');
                return;
            }

            const voiceName = azureVoiceMap[lang];
            const azureLangCode = azureLanguageMap[lang] || 'en-IN';

            if (!voiceName) {
                console.warn(`No specific Azure voice mapped for language '${lang}'. Falling back to 'en-IN-NeerjaNeural'.`);
                voiceName = 'en-IN-NeerjaNeural';
            }

            // Construct SSML for better control over voice and language
            const ssml = `<speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="${azureLangCode}">
                                <voice name="${voiceName}">${text}</voice>
                            </speak>`;

            console.log("Attempting Azure TTS with SSML:", ssml);

            azureSynthesizer.speakSsmlAsync(
                ssml,
                result => {
                    if (result.reason === SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                        console.log("Synthesis finished successfully for: " + text);
                    } else if (result.reason === SpeechSDK.ResultReason.Canceled) {
                        console.error("Synthesis canceled (result): " + result.errorDetails);
                        isSpeaking = false;
                        // stopSpeechButton.classList.remove('show');
                        stopBotResponseButtonDialog.style.display = 'none';
                    } else {
                        console.error("Synthesis failed with unexpected result reason. Result ID: " + result.resultId + "\n" +
                            "Error reason: " + result.reason + "\n" +
                            "Error details: " + result.errorDetails);
                        isSpeaking = false;
                        // stopSpeechButton.classList.remove('show');
                        stopBotResponseButtonDialog.style.display = 'none';
                    }
                },
                error => {
                    console.error("Critical error during Azure synthesis: " + error);
                    isSpeaking = false;
                    // stopSpeechButton.classList.remove('show');
                    stopBotResponseButtonDialog.style.display = 'none';
                }
            );
        }

        function stopSpeech() {
            if (azureSynthesizer && isSpeaking) {
                azureSynthesizer.close();
                azureSynthesizer = null;
                isSpeaking = false;
                // stopSpeechButton.classList.remove('show');
                stopBotResponseButtonDialog.style.display = 'none'; // Hide dialog stop button
                console.log('Azure speech stopped by user (synthesizer closed).');
            }
            // If in speech-to-speech mode and speech was stopped, restart listening, if bot is not stopped
            if (currentChatMode === 'speech-to-speech' && voiceDialog.style.display === 'flex' && !botResponsesStopped) {
                azureSpeechRecognizer.startRecognition();
            }
        }
        // --- End Azure Speech Synthesis (TTS) Implementation ---

        function updateInterface(lang) {
            const t = translations[lang];

            document.querySelector('.header p').textContent = t.powered;
            document.querySelector('.settings-toggle').innerHTML = `‚öôÔ∏è ${t.settings}`;

            document.querySelector('.settings-header h2').textContent = t.settings;
            document.querySelector('.close-settings').textContent = t.close;

            document.querySelector('label[for="languageSelect"]').textContent = t.language;
            document.querySelector('label[for="modelSelect"]').textContent = t.model;
            document.querySelector('label[for="systemPrompt"]').textContent = t.systemPrompt;

            document.getElementById('messageInput').placeholder = t.inputPlaceholder;
            document.getElementById('sendButton').textContent = t.send;
            mainLoadingIndicator.textContent = t.thinking;
            voiceLoadingIndicator.textContent = t.thinking;

            document.querySelector('.voice-dialog-header h3').textContent = t.voiceInput;
            document.getElementById('startListening').textContent = t.startListening;
            document.getElementById('stopListening').textContent = t.stopListening;
            document.getElementById('sendVoiceMessage').textContent = t.send;

            // stopSpeechButton.innerHTML = `üîá ${t.stopSpeech}`; // This button is removed
            stopBotResponseButtonDialog.textContent = t.stopBotResponseButtonText; // Update the new dialog button's text

            // Update the new toggle button in settings
            if (botResponsesStopped) {
                stopBotToggle.innerHTML = `üîä ${t.resumeBotResponses}`;
                stopBotToggle.classList.add('active');
            } else {
                stopBotToggle.innerHTML = `üîá ${t.stopBotResponses}`;
                stopBotToggle.classList.remove('active');
            }

            // Update mode toggle button text
            modeToggle.innerHTML = currentChatMode === 'text-to-text' ? `üí¨ ${t.textMode}` : `üé§ ${t.speechMode}`;

            updateWelcomeMessage(lang);
        }

        function updateWelcomeMessage(lang) {
            const messagesContainer = document.getElementById('messages');
            if (messagesContainer.children.length === 0 ||
                (messagesContainer.children.length === 1 && messagesContainer.children[0].textContent.includes("Welcome!"))) {
                messagesContainer.innerHTML = '';
                addMessage(translations[lang].welcome, false);
            }
        }

        function saveSettings() {
            const settings = {
                model: document.getElementById('modelSelect').value,
                systemPrompt: document.getElementById('systemPrompt').value,
                language: document.getElementById('languageSelect').value,
                chatMode: currentChatMode,
                botResponsesStopped: botResponsesStopped // Save the new state
            };
            localStorage.setItem('indicoreSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('indicoreSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                document.getElementById('modelSelect').value = settings.model || 'sonar-pro';
                document.getElementById('systemPrompt').value = settings.systemPrompt || 'You are a helpful Multilingual AI assistant. Your name is Indicore-Ai. Provide accurate, detailed, and well-structured responses.';
                document.getElementById('languageSelect').value = settings.language || 'en';

                currentChatMode = settings.chatMode || 'text-to-text';
                botResponsesStopped = settings.botResponsesStopped || false; // Load the new state

                updateInterface(settings.language || 'en');
                applyChatMode(currentChatMode);

                const modelInfo = document.getElementById('modelInfo');
                modelInfo.textContent = modelDescriptions[settings.model || 'sonar-pro'];
            } else {
                addMessage(translations['en'].welcome, false);
                applyChatMode('text-to-text');
            }
        }

        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            panel.classList.toggle('active');
            saveSettings();
        }

        // New function to toggle bot responses on/off
        function toggleBotResponses() {
            botResponsesStopped = !botResponsesStopped;
            const lang = document.getElementById('languageSelect').value;
            updateInterface(lang); // Update button text and class
            saveSettings();

            if (botResponsesStopped) {
                stopSpeech(); // Immediately stop any ongoing speech if bot is stopped
                if (currentChatMode === 'speech-to-speech' && azureSpeechRecognizer.isListening) {
                    azureSpeechRecognizer.stopRecognition(); // Stop recognition as well
                }
                addMessage(`Bot responses are now ${translations[lang].stopBotResponses.includes('Stop') ? 'stopped' : '‡§∞‡•ã‡§ï‡•á ‡§ó‡§è'}.`, false);
            } else {
                addMessage(`Bot responses are now ${translations[lang].resumeBotResponses.includes('Resume') ? 'resumed' : '‡§™‡•Å‡§®‡§É ‡§∂‡•Å‡§∞‡•Ç'}.`, false);
                // If in speech mode, and now resumed, restart listening
                if (currentChatMode === 'speech-to-speech' && voiceDialog.style.display === 'flex' && !azureSpeechRecognizer.isListening) {
                    azureSpeechRecognizer.startRecognition();
                }
            }
        }


        function toggleMode() {
            if (currentChatMode === 'text-to-text') {
                currentChatMode = 'speech-to-speech';
            } else {
                currentChatMode = 'text-to-text';
                if (azureSpeechRecognizer.isListening) {
                    azureSpeechRecognizer.stopRecognition();
                }
                voiceDialog.style.display = 'none';
                stopSpeech(); // Stop any speech if user switches to text mode
            }
            saveSettings();
            applyChatMode(currentChatMode);
            updateInterface(document.getElementById('languageSelect').value);
        }

        function applyChatMode(mode) {
            if (mode === 'text-to-text') {
                chatContainer.classList.remove('speech-mode');
                chatContainer.classList.add('text-mode');
                messageInput.style.display = 'block';
                sendButton.style.display = 'flex';
                micButton.style.display = 'none';
                voiceDialog.style.display = 'none';
                mainLoadingIndicator.classList.remove('active');
                voiceLoadingIndicator.classList.remove('active');
                stopBotResponseButtonDialog.style.display = 'none'; // Hide the dialog stop button
            } else { // speech-to-speech
                chatContainer.classList.remove('text-mode');
                chatContainer.classList.add('speech-mode');
                messageInput.style.display = 'none';
                sendButton.style.display = 'none';
                micButton.style.display = 'flex';
                mainLoadingIndicator.classList.remove('active');
                voiceDialog.style.display = 'flex';
                // Only start recognition if bot responses are not stopped
                if (!botResponsesStopped) {
                    azureSpeechRecognizer.startRecognition();
                } else {
                    const lang = document.getElementById('languageSelect').value;
                    voiceStatus.textContent = `Bot responses are ${translations[lang].stopBotResponses.includes('Stop') ? 'stopped' : '‡§∞‡•ã‡§ï‡•á ‡§ó‡§è'}. Listening disabled.`;
                }
            }
        }

        function addMessage(content, isUser) {
            const messagesContainer = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;

            messageDiv.appendChild(contentDiv);
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            const language = document.getElementById('languageSelect').value;
            const t = translations[language];

            if (!message) {
                alert(t.errorNoMessage);
                return;
            }

            // Immediately check if bot responses are stopped
            if (botResponsesStopped) {
                addMessage("Bot responses are currently stopped.", false);
                console.log("Bot responses are stopped. Not sending message to API.");
                messageInput.value = ''; // Clear input even if not sent
                // In speech mode, resume listening after user input if bot is stopped (no API call)
                if (currentChatMode === 'speech-to-speech' && voiceDialog.style.display === 'flex' && !azureSpeechRecognizer.isListening) {
                    azureSpeechRecognizer.startRecognition();
                }
                return; // Stop the function here
            }

            if (currentChatMode === 'text-to-text') {
                addMessage(message, true);
            }
            updateQuestionCounter();
            messageInput.value = '';

            if (currentChatMode === 'text-to-text') {
                mainLoadingIndicator.classList.add('active');
            } else {
                voiceLoadingIndicator.classList.add('active');
                voiceDialog.style.display = 'flex';
                if (azureSpeechRecognizer.isListening) {
                    azureSpeechRecognizer.stopRecognition();
                }
            }
            sendButton.disabled = false; // Keep Send button enabled for new messages
            micButton.disabled = true; // Still disable mic during API call

            try {
                let model = document.getElementById('modelSelect').value;
                const modelMap3 = {
                    'sonar-medium-online': 'sonar',
                    'sonar-small-online': 'sonar-small'
                };
                if (modelMap3[model]) model = modelMap3[model];
                let systemPrompt = document.getElementById('systemPrompt').value.trim();

                if (language !== 'en') {
                    systemPrompt += ` Your response MUST be entirely in ${translations[language].languageName}. Do not use any other language. Ensure perfect grammar and natural flow in ${translations[language].languageName}.`;
                }

                console.log(`Sending prompt to Perplexity in ${language} with system prompt: "${systemPrompt}" and user message: "${message}"`);

                const response = await fetch('https://api.perplexity.ai/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.perplexity.key}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify((() => {
                        const payload = {
                        model: model,
                            messages: [
                                { role: "system", content: systemPrompt },
                                { role: "user", content: message }
                            ],
                        max_tokens: 1000,
                        temperature: 0.7,
                        top_p: 0.9,
                        stream: false,
                        presence_penalty: 0,
                        frequency_penalty: 1
                        };
                        if (model.includes('sonar')) {
                            payload.search_domain_filter = ["perplexity.ai"];
                            payload.return_images = false;
                            payload.return_related_questions = false;
                            payload.search_recency_filter = "month";
                            payload.top_k = 0;
                        }
                        return payload;
                    })())
                });

                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('API Error from Perplexity:', response.status, errorData);
                    throw new Error(`HTTP ${response.status}: ${errorData}`);
                }

                const data = await response.json();

                let aiResponse = '';
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    aiResponse = data.choices[0].message.content;
                } else {
                    throw new Error('Invalid response format from Perplexity API');
                }

                console.log('Perplexity AI Raw Response Content:', aiResponse);
                console.log('Selected Language for TTS:', language);

                if (currentChatMode === 'text-to-text') {
                    addMessage(aiResponse, false);
                }

                if (currentChatMode === 'speech-to-speech' && aiResponse.trim().length > 0) {
                    speak(aiResponse, language);
                } else if (currentChatMode === 'speech-to-speech' && aiResponse.trim().length === 0) {
                    console.warn("Speech mode active, but AI returned empty response. Not speaking.");
                    if (voiceDialog.style.display === 'flex' && !botResponsesStopped) {
                        azureSpeechRecognizer.startRecognition();
                    }
                } else {
                    console.log("Text mode active, or no content to speak.");
                }

            } catch (error) {
                console.error('Error in sendMessage function:', error);
                let errorMessage = `Error: ${error.message}`;

                if (error.message.includes('401')) {
                    errorMessage = "Invalid API key. Please check your Perplexity API key in settings.";
                } else if (error.message.includes('429')) {
                    errorMessage = "Rate limit exceeded. Please wait a moment and try again.";
                } else if (error.message.includes('402')) {
                    errorMessage = "Insufficient credits. Please add credits to your Perplexity account.";
                } else if (error.message.includes('403')) {
                    errorMessage = "Access denied. Please verify your API key permissions.";
                }

                addMessage(errorMessage, false);
                if (currentChatMode === 'speech-to-speech') {
                    speak(errorMessage, language);
                }

            } finally {
                mainLoadingIndicator.classList.remove('active');
                voiceLoadingIndicator.classList.remove('active');
                sendButton.disabled = false;
                micButton.disabled = false;
                messageInput.focus();
                if (currentChatMode === 'speech-to-speech' && !isSpeaking && !azureSpeechRecognizer.isListening && voiceDialog.style.display === 'flex' && !botResponsesStopped) {
                    azureSpeechRecognizer.startRecognition();
                }
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && currentChatMode === 'text-to-text') {
                sendMessage();
            }
        }

        // Voice input event listeners (modified for mode)
        micButton.addEventListener('click', function() {
            if (currentChatMode === 'speech-to-speech') {
                voiceDialog.style.display = 'flex';
                const lang = document.getElementById('languageSelect').value;
                document.getElementById('voiceStatus').textContent = translations[lang].voiceStatusStart;
                resetTranscription();
                // Only start recognition if bot responses are not stopped
                if (!botResponsesStopped) {
                    azureSpeechRecognizer.startRecognition();
                } else {
                    voiceStatus.textContent = `Bot responses are ${translations[lang].stopBotResponses.includes('Stop') ? 'stopped' : '‡§∞‡•ã‡§ï‡•á ‡§ó‡§è'}. Listening disabled.`;
                }
            }
        });

        closeDialog.addEventListener('click', function() {
            voiceDialog.style.display = 'none';
            finalTranscriptText = '';
            resetTranscription();
            if (azureSpeechRecognizer.recognizer && azureSpeechRecognizer.isListening) {
                azureSpeechRecognizer.stopRecognition();
            }
            stopSpeech(); // Stop any ongoing speech if dialog is closed
        });

        startListening.addEventListener('click', function() {
            if (!botResponsesStopped) {
                azureSpeechRecognizer.startRecognition();
            } else {
                const lang = document.getElementById('languageSelect').value;
                voiceStatus.textContent = `Bot responses are ${translations[lang].stopBotResponses.includes('Stop') ? 'stopped' : '‡§∞‡•ã‡§ï‡•á ‡§ó‡§è'}. Cannot start listening.`;
            }
        });

        stopListening.addEventListener('click', function() {
            azureSpeechRecognizer.stopRecognition();
        });

        sendVoiceMessage.addEventListener('click', function() {
            const transcriptText = transcription.textContent.trim();
            const lang = document.getElementById('languageSelect').value;

            if (transcriptText &&
                transcriptText !== translations[lang].transcriptionPlaceholder) {
                messageInput.value = transcriptText;
                voiceDialog.style.display = 'none';
                sendMessage();

                finalTranscriptText = '';
                resetTranscription();
            }
        });

        // Event listener for the new "Stop Bot Response" button inside the dialog
        stopBotResponseButtonDialog.addEventListener('click', stopSpeech);

        document.getElementById('languageSelect').addEventListener('change', function() {
            updateInterface(this.value);
            saveSettings();
        });

        document.getElementById('modelSelect').addEventListener('change', function() {
            const modelInfo = document.getElementById('modelInfo');
            modelInfo.textContent = modelDescriptions[this.value];
            saveSettings();
        });

        document.addEventListener('DOMContentLoaded', async function() {
            loadSettings(); // Load all settings including botResponsesStopped
            loadQuestionStats();

            if (typeof SpeechSDK === 'undefined') {
                console.error('Azure Speech SDK not loaded');
                document.getElementById('voiceStatus').textContent = 'Azure Speech SDK not loaded. Voice input and output disabled.';
                micButton.disabled = true;
                // If SDK is not loaded, ensure speech-related buttons are disabled
                startListening.disabled = true;
                stopListening.disabled = true;
                sendVoiceMessage.disabled = true;
                stopBotResponseButtonDialog.disabled = true; // Disable this dialog button as well
                stopBotToggle.disabled = true; // Disable this toggle if speech isn't available
            } else {
                initializeAzureSynthesizer();
                micButton.disabled = false;
            }
        });
    const BACKEND_URL = (location.hostname === '127.0.0.1' || location.hostname === 'localhost')
        ? 'http://127.0.0.1:5000/api'
        : 'https://indicore-ok6j7ky8j-manas-mathurs-projects.vercel.app/api';

async function checkBackend() {
    try {
        const response = await fetch(`${BACKEND_URL}/ping`);
        if (response.ok) {
            document.getElementById("backend-status").textContent = "Backend Status: ‚úÖ Connected";
        } else {
            document.getElementById("backend-status").textContent = "Backend Status: ‚ùå Not Connected";
        }
    } catch (err) {
        document.getElementById("backend-status").textContent = "Backend Status: ‚ùå Not Connected";
        console.error("Backend connection error:", err);
    }
}
// Load previous chats
function loadChats() {
    fetch(`${BACKEND_URL}/chats?email=${currentUser.email}`)
        .then(res => res.json())
        .then(chats => {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';
            chats.forEach(chat => {
                const div = document.createElement('div');
                div.classList.add('chat-item');
                div.textContent = chat.name || `Chat ${chats.indexOf(chat)+1}`;
                div.onclick = () => loadChat(chat._id);
                chatList.appendChild(div);
            });
        });
}

// Load single chat messages
function loadChat(chatId) {
    fetch(`${BACKEND_URL}/chat?id=${chatId}`)
        .then(res => res.json())
        .then(chat => {
            currentChatId = chat._id;
            displayMessages(chat.messages);
        });
}

function displayMessages(messages) {
    const messagesContainer = document.querySelector('.messages');
    messagesContainer.innerHTML = '';
    messages.forEach(m => {
        const div = document.createElement('div');
        div.classList.add('message', m.sender);
        div.innerHTML = `<div class="message-content">${m.text}</div>`;
        messagesContainer.appendChild(div);
    });
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Create new chat
document.getElementById('newChatBtn').onclick = () => {
    fetch(`${BACKEND_URL}/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: currentUser.email })
    })
    .then(res => res.json())
    .then(chat => loadChats());
};

// Example: sending a message
function sendBackendMessage(text) {
    if(!currentChatId) return;
    fetch(`${BACKEND_URL}/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ chatId: currentChatId, sender: 'user', text, email: currentUser.email })
    })
    .then(res => res.json())
    .then(chat => displayMessages(chat.messages));
}


checkBackend();
let currentUser = null;
let currentChatId = null;


 </script>
 <script src="https://accounts.google.com/gsi/client" async defer></script>
<script>
// Google GIS credential callback: saves session and registers on backend
async function handleCredentialResponse(response) {
    try {
        if (!response || !response.credential) {
            alert('Google login failed. Try again.');
            return;
        }
        const userObject = jwt_decode(response.credential);
        const userId = userObject.sub;

        localStorage.setItem('indicore_user', JSON.stringify({
            id: userId,
            email: userObject.email,
            name: userObject.name,
            picture: userObject.picture
        }));

        try {
            const res = await fetch(`${BACKEND_URL}/auth/google`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    googleId: userId,
                    name: userObject.name,
                    email: userObject.email,
                    picture: userObject.picture
                })
            });
            const data = await res.json();
            window.currentUser = (data && data.user) ? data.user : { googleId: userId, name: userObject.name, email: userObject.email, picture: userObject.picture };
        } catch (e) {
            console.warn('Backend auth failed, continuing locally.', e);
            window.currentUser = { googleId: userId, name: userObject.name, email: userObject.email, picture: userObject.picture };
        }

        const modal = document.getElementById('loginModal');
        if (modal) modal.style.display = 'none';
        if (typeof loadChats === 'function') loadChats();
    } catch (err) {
        console.error('Login error', err);
        alert('Login failed. See console.');
    }
}
</script>
<!-- Google Login Modal -->
<div id="loginModal" class="login-modal">
    <div class="login-modal-content">
        <h3>Login with Google</h3>
        <div id="gSignInWrapper"></div>
    </div>
</div>
<!-- Collapsible Sidebar for Memory / Previous Chats -->
<div id="sidebar" class="sidebar">
    <div class="sidebar-header">
        <h2>Your Chats</h2>
        <button id="closeSidebar">X</button>
    </div>
    <div id="chatList" class="chat-list">
        <!-- Chats will be dynamically added here -->
    </div>
    <button id="newChatBtn">+ New Chat</button>
</div>
<script src="https://accounts.google.com/gsi/client" async defer></script>
<script>


// Initialize Google button on window load
window.addEventListener('load', () => {
    // Google login initialization (GIS credential flow)
    google.accounts.id.initialize({
        client_id: '1097925043802-fcpnplt7jp64s0ljlo1nf2rcdl3gpncl.apps.googleusercontent.com',
        callback: handleCredentialResponse
    });
    google.accounts.id.renderButton(
        document.getElementById('gSignInWrapper'),
        { theme: 'outline', size: 'large', width: 220 }
    );
    document.getElementById('loginModal').style.display = 'flex';

    // Load saved settings and question stats
    loadSettings();
    loadQuestionStats();

    // Initialize Azure TTS if SDK loaded
    if (typeof SpeechSDK === 'undefined') {
        console.error('Azure Speech SDK not loaded');
        document.getElementById('voiceStatus').textContent = 'Azure Speech SDK not loaded. Voice input and output disabled.';
        // Disable all speech buttons
        micButton.disabled = true;
        startListening.disabled = true;
        stopListening.disabled = true;
        sendVoiceMessage.disabled = true;
        stopBotResponseButtonDialog.disabled = true;
        stopBotToggle.disabled = true;
    } else {
        initializeAzureSynthesizer();
        micButton.disabled = false;
    }
});


// Sidebar toggle
const openSidebarBtn = document.getElementById('openSidebar');
if (openSidebarBtn) {
    openSidebarBtn.onclick = () => {
        document.getElementById('sidebar').classList.add('active');
    };
}
const closeSidebarBtn = document.getElementById('closeSidebar');
if (closeSidebarBtn) {
    closeSidebarBtn.onclick = () => {
        document.getElementById('sidebar').classList.remove('active');
    };
}
</script>


</body>

</html>